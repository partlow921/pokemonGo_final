import random

class Item(object):

    #Add doc string

    def __init__(self, name_str="-"):
        self.name=name_str


    def __repr__(self):
        return self.name

    def invoke(self,player):
        pass

    def remove_item_from(self,player):
        player.bag.remove_item(self)

class Potion(Item):

    def __init__(self,name):
        self.restore_amount = 0
        super(self.__class__, self).__init__(name)
        if(self.name == "Potion"):
            self.restore_amount=20
        elif(self.name == "Super Potion"):
            self.restore_amount=50
        elif(self.name == "Hyper Potion"):
            self.restore_amount=200
        elif(self.name == "Max Potion"):
            self.restore_amount=500
            #needs to set current to pokemon hp total, full restore
        else:
            self.restore_amount=0

    def invoke(self,player):

        prompt_message=""
        i=1
        for pokemon in player.pokemon_in_hand:
            prompt_message+=str(i)+":"+pokemon.name+" (HP: "+str(pokemon.current_hp)+"/"+str(pokemon.hp)+")  "
            i+=1
        user_item_selected = int(input("Please choose a Pokemon to use "+self.name+" on. (Enter 0 to go back): \n"+prompt_message+"\n"))
        if(user_item_selected!=0):
            pokemon=player.pokemon_in_hand[user_item_selected-1]

            if(pokemon.current_hp>0):
                amount_restored = min(pokemon.hp - pokemon.current_hp, self.restore_amount)
                pokemon.current_hp += amount_restored
                print("Restored " + str(amount_restored) + " to " + pokemon.name + ". Current HP is now " + str(pokemon.current_hp))
            else:
                print("Cannot use potions on Pokemon who have fainted. Use Revive first.")
                #do not decrease items
            self.remove_item_from(player)

class Revive(Item):

    def __init__(self,name):
        #add health resotred
        super(self.__class__,self).__init__(name)
        #add types of revive to determine how much HP is restored in addition to being revived

    def invoke(self,player):

        prompt_message=""
        i=1
        for pokemon in player.pokemon_in_hand:
            prompt_message+=str(i)+":"+pokemon.name+" (HP: "+str(pokemon.current_hp)+"/"+str(pokemon.hp)+")  "
            i+=1
        user_item_selected = int(input("Please choose a Pokemon to use "+self.name+" on. (Enter 0 to go back): \n"+prompt_message+"\n"))
        if(user_item_selected!=0):
            pokemon=player.pokemon_in_hand[user_item_selected-1]

            if(pokemon.current_hp==0):
                pokemon.current_hp=int(pokemon.hp/2)
                print(pokemon.name + " has been revived! Current HP is " + str(pokemon.current_hp))
            else:
                print(pokemon.name + " is alive. Please select another Pokemon or use a different item")
                #do not decrease items
            self.remove_item_from(player)


class PokeBall(Item):

    def __init__(self,name):
        self.capture_chance = 0.5
        super(self.__class__,self).__init__(name)
        if(self.name == "Poke Ball"):
            self.capture_chance = 0.50
        elif(self.name == "Great Ball"):
            self.capture_chance = 0.70
        elif(self.name == "Ultra Ball"):
            self.capture_chance = 0.85
        #add additional pokeball types
        else:
            self.capture_chance = 0.5

    def invoke(self,player):
        pokemon = player.encountering_pokemon[0]
        #needs error handling if selected outside capture module.
        print("~~~~~~~~~~~~~~0~~~~~~~~~~~~~~~~")
        catch = random.uniform(pokemon.pokemon_level/100,1)
        #needs cap to be variable based on level as well so lvl 1 doesn't have chance of 1
        #vary catch variable generated by encounter level
        if(catch < self.capture_chance * pokemon.catch_chance):
            print(pokemon.name + " has bee captured!")
            player.pokemon_in_hand.append(pokemon)
            player.increase_experience(pokemon.pokemon_level*10)
            player.encountering_pokemon.remove(pokemon)
        else:
            print("It failed! "+pokemon.name+" could not be caught")
        self.remove_item_from(player)

class RazzBerry(Item):

    def __init__(self,name):
        self.catch_chance_modifier = 1.0
        super(self.__class__,self).__init__(name)
        if(self.name == "RazzBerry"):
            self.catch_chance_modifier = 1.1
        elif(self.name == "Great RazzBerry"):
            self.catch_chance_modifier = 1.2
        else:
            self.catch_chance_modifier = 1.0

    def invoke(self,player):
        pokemon=player.encounter_pokemon[0]
        print(pokemon.name + " is eating "+ self.name)
        pokemon.catch_chance*=self.catch_chance_modifier
        self.remove_item_from(player)

#...other items?
